import graphviz
from heapq import *

class WeightedGraph:
    def __init__(self, start):
        self._weightlist = None #dict

    def get_weight(self, a, b):
        return self._weightlist[a][b]

    def set_weight(self, a, b, w):
        self._weightlist[a][b] = w

class Graph(graphviz.Graph):
    def __init__(self, edgelist: list = None): # edge_list = [(x,y), (z,a)]
        super().__init__()
        self.engine = 'neato'
        self._adjlist = {}
        self._valuelist = {}
        if edgelist:
            self.init_using_edgelist(edgelist)

    def init_using_edgelist(self, edgelist):
        for tuple in edgelist:
            self.add_edge(tuple[0], tuple[1])
            self.add_vertex(tuple[0])
            self.add_vertex(tuple[1])

    def __len__(self):
        return len(self._valuelist)

    def add_edge(self, a, b):
        if a in self._adjlist:
            if b not in self._adjlist[a]:
                self._adjlist[a].append(b)
        else:
            self._adjlist[a] = [b]
        if b in self._adjlist:
            if a not in self._adjlist[b]:
                self._adjlist[b].append(a)
        else:
            self._adjlist[b] = [a]

    def add_vertex(self, a):
        if a not in self._valuelist:
            self._valuelist[a] = None
        if a not in self._adjlist:
            self._adjlist[a] = []

    def get_edges(self):
        edges = []
        for vertex, neighbours in self._adjlist.items():
            for neighbour in neighbours:
                if (vertex, neighbour) not in edges and (neighbour, vertex) not in edges:
                    edges.append((vertex, neighbour))
        return edges

    def get_vertex_value(self, v):
        return self._valuelist[v]

    def get_neighbours(self, v):
        return [neighbour for neighbour in self._adjlist[v]]

    def remove_edge(self, a, b):
        if a in self._adjlist:
            if b in self._adjlist[a]:
                self._adjlist[a].remove(b)
        if b in self._adjlist:
            if a in self._adjlist[b]:
                self._adjlist[b].remove(a)

    def remove_vertex(self, v):
        self._adjlist.pop(v)
        for item in self._adjlist:
            if v in self._adjlist[item]:
                self._adjlist[item].pop(v)
        self._valuelist.pop(v)

    def set_vertex_value(self, v, x):
        self._valuelist[v] = x

    def get_vertices(self):
        return [vertice for vertice in self._valuelist]

    def add_nodes_and_edges(self):
        edge_list = self.get_edges()
        vertices = self.get_vertices()

        for i in range(len(vertices)):
            self.node(f"{vertices[i]._name}", f'{vertices[i]._name}',
                       pos=f'{vertices[i]._position[1] * 200},{vertices[i]._position[0] * 200}!',
                       shape='rectangle', width='0.2', labelfontsize='7', fontsize='10')

        for edge in edge_list:
            self.edge(edge[0]._name, edge[1]._name, constraint='false')

    def colour_path(self, path_list: list):
        new_list = [self.get_vertices()[a] for a in range(len(self.get_vertices()))]
        for i in range(len(path_list)):
            the_index = new_list.index(path_list[i])
            self.node(path_list[i]._name, path_list[i]._name,
                          pos=f'{self.get_vertices()[the_index]._position[1] * 200},{self.get_vertices()[the_index]._position[0] * 200}!',
                          shape='circle', width='0.2', labelfontsize='7', fontsize='10', fillcolor='red',
                          style='filled')

        for i in range(len(path_list) - 1):
            self.edge(path_list[i]._name, path_list[i + 1]._name, constraint='false', color='red')

    def render_map(self):
        self.render(directory='stations', view=True)

    def dijkstra(self, source, target, cost = lambda u, v: 1):
        path_lengths = {v: 9999 for v in self.get_vertices()}
        prev = {previous: None for previous in self.get_vertices()}
        path_lengths[source] = 0
        unseen_vertices = [v for v in self.get_vertices()]

        while unseen_vertices:
            upper_bounds = {v: path_lengths[v] for v in unseen_vertices}
            u = min(upper_bounds, key = upper_bounds.get)
            unseen_vertices.remove(u)

            for v in self.get_neighbours(u):
                alt = path_lengths[u] + self.get_transition_time(u, v)
                if alt < path_lengths[v]:
                    path_lengths[v] = alt
                    prev[v] = u

        keys = list(prev.keys())
        paths = {}

        for i in prev.keys():
            path = [i]
            for key in keys:
                while key != i and path[-1] is not None:
                    path.append(prev[path[-1]])
            path.pop()
            paths[i] = path

        paths_with_time = {stop: {'path': paths[stop], 'dist': None} for stop in paths}
        for stop in path_lengths:
            paths_with_time[stop]['dist'] = path_lengths[stop]

        return paths_with_time[target]













