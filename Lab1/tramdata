import sys
from math import sin, cos, sqrt, atan2, pi
import json
import csv

STOPS_JSON_FILE = 'tramstops.json'
TRAMLINES_TSV_FILE = 'tramlines.tsv'

def reading_json_file():
    infile = 'tramnetwork.json'
    with open(infile, 'r') as data:
        tramworks = json.load(data)
    return tramworks

##-----------------------------MAIN FUNCTION-------------------------------

def dialogue():
    running = True
    tramworks = reading_json_file()
    while running:
        input_string = input("The following formats are functioning:\nvia <stop>\nbetween <stop1> and <stop2>"
                             "\ntime with <line> from <stop1> to <stop2>\ndistance from <stop1> to <stop2>\nquit\n> ")
        if input_string == 'quit':
            print("Bye bye!")
            running = False
            continue
        else:
            answer = answer_query(input_string, tramworks)
        if answer:
            print(answer)
        else:
            print("Sorry, try again!")

##-----------------------------ADAPTING STRING AND ACTIVIATING CALCULATING METHODS-------------------------------

def answer_query(input_string, tramworks):
    if "via" in input_string:
        station = input_string.lstrip(' via ')
        station.lstrip().rstrip()
        answer = lines_via_stop(tramworks['lines'], station)
    elif 'between' in input_string and 'and' in input_string:
        stop1_and_stop2 = input_string.split('between')[1]
        stops = stop1_and_stop2.split(' and ')
        stop1 = stops[0].lstrip().rstrip()
        stop2 = stops[1].lstrip().rstrip()
        answer = lines_between_stops(tramworks['lines'], stop1, stop2)
    elif 'time with' in input_string and 'from' in input_string and 'to' in input_string:
        line_and_stops = input_string.lstrip('time with ')
        line = line_and_stops.split('from')[0].lstrip().rstrip()
        stops = line_and_stops.split('from')[1]
        stop1 = stops.split(' to ')[0].lstrip().rstrip()
        stop2 = stops.split(' to ')[1].lstrip().rstrip()
        answer = f"The time with {line} between {stop1} and {stop2} is {times_between_stops(tramworks, line, stop1, stop2)} minutes"
    elif 'distance from' in input_string and 'to' in input_string:
        stop1_and_stop2 = input_string.lstrip('distance from')
        stops = stop1_and_stop2.split(' to ')
        stop1 = stops[0].rstrip().lstrip()
        stop2 = stops[1].rstrip().lstrip()
        answer = f"There are {distance_between_stops(tramworks['stops'], stop1, stop2)} km between {stop1} and {stop2}"
    else:
        answer = None
    return answer

##-----------------------------CALCULATING METHODS-------------------------------

def lines_via_stop(somedict, stop):
    try:
        lines_via_stop = [line for line in somedict if stop in somedict[line]]
        if not lines_via_stop:
            return f"No lines via {stop}"
        else:
            return f"The following lines passes {stop}: {lines_via_stop}"
    except KeyError:
        return "Unknown arguments"

def lines_between_stops(somedict, stop1, stop2):
    try:
        lines = [line for line in somedict if stop1 in somedict[line] and stop2 in somedict[line]]
        if not lines:
            return (f"There are no lines between {stop1} and {stop2}")
        else:
            return f" The following lines passes {stop1} and {stop2}: {lines}"
    except KeyError:
        return "Unknown arguments"

def times_between_stops(somedict, line, stop1, stop2):
    try:
        if stop1 in somedict['lines'][line] and stop2 in somedict['lines'][line]:
            start_index = somedict['lines'][line].index(stop1)
            end_index = somedict['lines'][line].index(stop2)
            if start_index > end_index:
                start_index, end_index = end_index, start_index
            stations_between_stops = [somedict['lines'][line][i] for i in range(start_index, end_index + 1)]
        else:
            return f"{line} does not pass both {stop1} and {stop2}"

        time = 0
        for i in range(len(stations_between_stops)-1):
            time += somedict['times'][stations_between_stops[i]][stations_between_stops[i+1]]
        return time
    except KeyError:
        return "Unknown arguments"

def distance_between_stops(somedict, stop1, stop2):
    try:
        lon1 = somedict[stop1]["lon"] * pi/180
        lon2 = somedict[stop2]["lon"] * pi/180
        lat1 = somedict[stop1]["lat"] * pi/180
        lat2 = somedict[stop2]["lat"] * pi/180

        R = 6371.0

        lon_diff = abs(lon1 - lon2)
        lat_diff = abs(lat1 - lat2)

        a = (sin(lat_diff / 2)) ** 2 + cos(lat1) * cos(lat2) * (sin(lon_diff / 2)) ** 2
        c = 2 * atan2(sqrt(a), sqrt(1 - a))
        distance = R * c
        return round(distance, 3)

    except KeyError:
        return "Unknown arguments"

##-----------------------------READING TEXT-FILE AND ADAPTING TO USAGE-------------------------------

def reading_tsv_file(text_file):
    dict_of_lines = {}
    stops_in_line = {}
    with open(text_file) as file:
        rows = csv.reader(file, delimiter="\t")
        for line in rows:
            if not line:
                dict_of_lines[temp_var] = stops_in_line.copy()
                stops_in_line = {}
            elif len(line[0]) <= 3 and len(line[0]) > 0:
                temp_var = line[0].rstrip(":")
            else:
                try:
                    the_split = line[0].rsplit(" ", 1)
                    name = (the_split[0]).rstrip()
                    stops_in_line[name] = the_split[1]
                except IndexError:
                    pass
        dict_of_lines[temp_var] = stops_in_line.copy()
    return dict_of_lines

##-----------------------------CREATING THE THREE DICTIONARIES INDEPENDENTLY-------------------------------

def creating_lines(text_file):
    return {line: [stop for stop in text_file[line]] for line in text_file}

def creating_neighbours(text_file, tsv_read):
    dict_of_lines = text_file
    out_dict = {}
    for line_stops in dict_of_lines.values():
        for i in range(len(line_stops)-1):
            if line_stops[i] not in out_dict.keys():
                out_dict[line_stops[i]] = {line_stops[i+1]: time_distance(tsv_read, line_stops[i], line_stops[i+1])}
            else:
                out_dict[line_stops[i]][line_stops[i+1]] = time_distance(tsv_read, line_stops[i], line_stops[i+1])
    return out_dict

def build_trams_stops(jsonobject):
    with open(jsonobject, 'r') as infile:
        all_stops = json.load(infile)
        return {stop: {"lat": float(all_stops[stop]["position"][0]), "lon": float(all_stops[stop]["position"][1])} for stop in all_stops}

##-----------------------------METHODS USED BY CREATING NEIGHBOURS-------------------------------

def time_distance(file, stop1, stop2):
    for line in file:
        try:
            minutes1 = convert(file[line][stop1])
            minutes2 = convert(file[line][stop2])
            return abs(minutes1 - minutes2)
        except KeyError:
            continue

def convert(time):
    split = time.split(":")
    return int(split[1])

##-----------------------------CREATION AND FUSION OF THREE DICTIONARIES-------------------------------

def collect_all_data(json_stops, tsv_lines):
    tramnetwork = {}
    tsv_read = reading_tsv_file(tsv_lines)
    stops = build_trams_stops(json_stops)
    lines = creating_lines(tsv_read)
    times = creating_neighbours(lines, tsv_read)
    tramnetwork['stops'] = stops
    tramnetwork['lines'] = lines
    tramnetwork['times'] = times
    return tramnetwork

def create_json_file(data, filename = "tramnetwork.json"):
    with open(filename, 'w') as f:
        json.dump(data, f, indent=2)

##-----------------------------CREATING JSON FILE-------------------------------

def build_tram_network():
    data = collect_all_data(STOPS_JSON_FILE, TRAMLINES_TSV_FILE)
    create_json_file(data)

##-----------------------------CONTROLLING THE PROGRAM FLOW-------------------------------

if __name__ == '__main__':
    if sys.argv[1:] == ['init']:
        build_tram_network()
    else:
        dialogue()
